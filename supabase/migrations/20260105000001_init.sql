create table if not exists public.profiles (
  id uuid primary key references auth.users(id) on delete cascade,
  display_name text,
  bio text,
  avatar_url text,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create table if not exists public.bookmarks (
  id bigint generated by default as identity primary key,
  user_id uuid not null references auth.users(id) on delete cascade,
  post_slug text not null,
  created_at timestamptz not null default now(),
  constraint bookmarks_user_post_slug_key unique (user_id, post_slug)
);

create table if not exists public.comments (
  id bigint generated by default as identity primary key,
  user_id uuid not null references auth.users(id) on delete cascade,
  post_slug text not null,
  body text not null check (char_length(body) between 1 and 2000),
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create index if not exists comments_post_slug_created_at_idx
  on public.comments (post_slug, created_at desc);
create index if not exists comments_user_id_created_at_idx
  on public.comments (user_id, created_at desc);

create table if not exists public.newsletter_subscribers (
  id bigint generated by default as identity primary key,
  email text not null,
  created_at timestamptz not null default now(),
  constraint newsletter_subscribers_email_key unique (email)
);

create or replace function public.set_updated_at()
returns trigger
language plpgsql
as $$
begin
  new.updated_at = now();
  return new;
end;
$$;

drop trigger if exists profiles_set_updated_at on public.profiles;
create trigger profiles_set_updated_at
before update on public.profiles
for each row execute function public.set_updated_at();

drop trigger if exists comments_set_updated_at on public.comments;
create trigger comments_set_updated_at
before update on public.comments
for each row execute function public.set_updated_at();

create or replace function public.normalize_newsletter_email()
returns trigger
language plpgsql
as $$
begin
  new.email = lower(trim(new.email));
  return new;
end;
$$;

drop trigger if exists newsletter_subscribers_normalize_email on public.newsletter_subscribers;
create trigger newsletter_subscribers_normalize_email
before insert or update on public.newsletter_subscribers
for each row execute function public.normalize_newsletter_email();

create or replace function public.handle_new_user()
returns trigger
language plpgsql
security definer
set search_path = public, auth
as $$
begin
  insert into public.profiles (id, created_at, updated_at)
  values (new.id, now(), now())
  on conflict (id) do nothing;
  return new;
end;
$$;

drop trigger if exists on_auth_user_created on auth.users;
create trigger on_auth_user_created
after insert on auth.users
for each row execute function public.handle_new_user();

alter table public.profiles enable row level security;
alter table public.bookmarks enable row level security;
alter table public.comments enable row level security;
alter table public.newsletter_subscribers enable row level security;

drop policy if exists profiles_select_own on public.profiles;
create policy profiles_select_own
on public.profiles
for select
using (id = auth.uid());

drop policy if exists profiles_insert_own on public.profiles;
create policy profiles_insert_own
on public.profiles
for insert
with check (id = auth.uid());

drop policy if exists profiles_update_own on public.profiles;
create policy profiles_update_own
on public.profiles
for update
using (id = auth.uid())
with check (id = auth.uid());

drop policy if exists bookmarks_select_own on public.bookmarks;
create policy bookmarks_select_own
on public.bookmarks
for select
using (user_id = auth.uid());

drop policy if exists bookmarks_insert_own on public.bookmarks;
create policy bookmarks_insert_own
on public.bookmarks
for insert
with check (user_id = auth.uid());

drop policy if exists bookmarks_delete_own on public.bookmarks;
create policy bookmarks_delete_own
on public.bookmarks
for delete
using (user_id = auth.uid());

drop policy if exists comments_select_public on public.comments;
create policy comments_select_public
on public.comments
for select
using (true);

drop policy if exists comments_insert_own on public.comments;
create policy comments_insert_own
on public.comments
for insert
with check (user_id = auth.uid());

drop policy if exists comments_update_own on public.comments;
create policy comments_update_own
on public.comments
for update
using (user_id = auth.uid())
with check (user_id = auth.uid());

drop policy if exists comments_delete_own on public.comments;
create policy comments_delete_own
on public.comments
for delete
using (user_id = auth.uid());

drop policy if exists newsletter_insert_service_role on public.newsletter_subscribers;
create policy newsletter_insert_service_role
on public.newsletter_subscribers
for insert
with check (auth.role() = 'service_role');

drop policy if exists newsletter_select_service_role on public.newsletter_subscribers;
create policy newsletter_select_service_role
on public.newsletter_subscribers
for select
using (auth.role() = 'service_role');
